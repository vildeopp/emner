{\rtf1\ansi\ansicpg1252\cocoartf2577
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red191\green100\blue38;\red32\green32\blue32;\red254\green187\blue91;
\red153\green168\blue186;\red117\green114\blue185;\red88\green118\blue71;\red86\green132\blue173;\red109\green109\blue109;
\red95\green96\blue103;}
{\*\expandedcolortbl;;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c99608\c73333\c35686;
\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c45882\c44706\c72549;\csgenericrgb\c34510\c46275\c27843;\csgenericrgb\c33725\c51765\c67843;\csgenericrgb\c42745\c42745\c42745;
\csgenericrgb\c37255\c37647\c40392;}
\paperw11900\paperh16840\margl1440\margr1440\vieww20820\viewh13760\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \cb3 def \cf4 time_calculation\cf5 (solution: \cf6 list\cf2 , \cf5 vehicle: \cf6 int\cf5 ):\
\
    vehicle_info = problem[\cf7 'vehicle_info'\cf5 ].get(vehicle)\
    calls_info = problem[\cf7 'call_info'\cf5 ]\
    travel_time = problem[\cf7 'travel_cost'\cf5 ]\
    node_info = problem[\cf7 'node_time_cost'\cf5 ]\
\
    start_node = vehicle_info[\cf8 0\cf5 ]\
    start_time = vehicle_info[\cf8 1\cf5 ]\
\
    picked_up = []\
    route_calls = r.get_vehiclesroutes_aslist(solution)[vehicle] \cf9 #the route represented as calls\
    \cf5 route_nodes = r.call_to_nodes(problem\cf2 , \cf5 route_calls)\
    \
    \cf2 if not \cf5 route_nodes:\
        \cf6 print\cf5 (\cf7 "no nodes in car's route"\cf5 )\
        \cf2 return True\
\
    \cf5 dest_node = route_nodes.pop(\cf8 0\cf5 ) \cf9 #first node\
\
    \cf2 for \cf5 i\cf2 ,\cf5 calls \cf2 in \cf6 enumerate\cf5 (route_calls):\
        c_info = calls_info.get(calls)\
        pickup_node = c_info[\cf8 0\cf5 ]\
        \cf2 if \cf5 i == \cf8 0\cf5 :\
            key = (vehicle\cf2 , \cf5 start_node\cf2 , \cf5 pickup_node)\
            start_time += travel_time.get(key)[\cf8 0\cf5 ]\
\
        \cf10 pickup_node \cf5 = dest_node\
        \cf2 try\cf5 :\
            dest_node = route_nodes.pop(\cf8 0\cf5 )\
        \cf2 except \cf6 IndexError \cf2 as \cf10 e\cf5 :\
            dest_node = -\cf8 1\
\
        \cf5 key = (vehicle\cf2 , \cf5 calls)\
        \cf2 if \cf5 calls \cf2 not in \cf5 picked_up \cf2 and \cf5 dest_node != -\cf8 1\cf5 : \cf9 #means that the car is supposed to pickup\
            \cf5 picked_up.append(calls)\
            lower_tm_wd = c_info[\cf8 4\cf5 ]\
            upper_tm_wd = c_info[\cf8 5\cf5 ]\
            \cf9 #checks if the vehicle meets the lower time window requirement, if not -> time = the lower time window\
            \cf2 if \cf5 start_time < lower_tm_wd:\
                start_time = lower_tm_wd\
            \cf9 #checks if the vehicle meets the upper time window requirement, if not = infeasible\
            \cf2 if \cf5 start_time > upper_tm_wd:\
                \cf2 return False\
            \cf5 start_time += node_info.get(key)[\cf8 0\cf5 ]\
\
        \cf2 else\cf5 : \cf9 #means that the car is supposed to deliver\
            \cf5 picked_up.remove(calls)\
            lower_tm_wd = c_info[\cf8 6\cf5 ]\
            upper_tm_wd = c_info[\cf8 7\cf5 ]\
\
            \cf2 if \cf5 start_time < lower_tm_wd:\
                start_time = lower_tm_wd\
            \cf2 if \cf5 start_time > upper_tm_wd:\
                \cf2 return False\
            \cf5 start_time += node_info.get(key)[\cf8 2\cf5 ]\
\
        \cf9 #changes the origin and delivery nodes\
        \cf5 start_node = dest_node\
        \cf2 try\cf5 :\
            dest_node = route_nodes.pop(\cf8 0\cf5 )\
        \cf2 except \cf6 IndexError \cf2 as \cf10 e\cf5 :\
            dest_node = -\cf8 1\
\
    \cf6 print\cf5 (\cf7 "time at the end: "\cf2 , \cf5 start_time)\
\
    \cf2 return True\
}